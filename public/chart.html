<!DOCTYPE html>
<html>
<head>
    <title>Ë≥áÈáëÊµÅÂêëËøΩËπ§</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Dagre for graph layout -->
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>
    <style>
        :root { --bg-color: #1a1a1d; --panel-bg: rgba(30, 30, 35, 0.95); --border-color: #33333a; --accent-green: #4fa28a; --accent-red: #ba3029; --text-main: #e0e0e0; --text-sub: #888890; --gold: #f0b90b; }
        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }
        body { background: var(--bg-color); color: var(--text-main); font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; }

        #svgContainer {
            width: 100vw; height: calc(100vh - 48px); margin-top: 48px;
            overflow: hidden; cursor: grab;
            -webkit-overflow-scrolling: touch;
            touch-action: none;
        }
        #svgContainer.dragging { cursor: grabbing; }
        body:not(.panel-collapsed) #svgContainer { margin-left: 280px; width: calc(100vw - 280px); }
        body.panel-collapsed #svgContainer { margin-left: 0; width: 100vw; }

        svg {
            display: block;
            will-change: transform;
            transform-origin: 0 0;
        }
        .node-box { fill: #1e1e24; stroke: #3a3a42; stroke-width: 1; cursor: pointer; transition: all 0.2s; }
        .node-box:hover { stroke: var(--accent-green); stroke-width: 2; }
        .node-box.target { fill: rgba(240, 185, 11, 0.15); stroke: var(--gold); stroke-width: 2; }
        .node-box.expanded { fill: rgba(79, 162, 138, 0.15); stroke: var(--accent-green); stroke-width: 2; }
        .node-text { fill: #aaa; font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; pointer-events: none; }
        .node-text.target { fill: var(--gold); }
        .node-text.expanded { fill: var(--accent-green); }

        .edge-path { fill: none; stroke-width: 1.5; opacity: 0.8; }
        .edge-path.usdt { stroke: var(--accent-green); }
        .edge-path.trx { stroke: var(--accent-red); }
        .edge-arrow { stroke: none; }
        .edge-arrow.usdt { fill: var(--accent-green); }
        .edge-arrow.trx { fill: var(--accent-red); }

        .label-text { font-family: 'Inter', sans-serif; font-size: 10px; pointer-events: auto; cursor: pointer; }
        .label-text:hover { filter: brightness(1.3); }
        .label-text.usdt { fill: var(--accent-green); }
        .label-text.trx { fill: var(--accent-red); }
        .label-bg { fill: rgba(26, 26, 29, 0.95); cursor: pointer; rx: 3; }
        .label-bg:hover { fill: rgba(40, 40, 45, 0.95); }

        .top-bar { position: fixed; top: 0; left: 0; right: 0; height: 48px; background: #0d0d0d; border-bottom: 1px solid #2a2a2a; display: flex; align-items: center; padding: 0 16px; gap: 12px; z-index: 200; }
        .top-bar-title { font-size: 14px; font-weight: 600; color: #fff; display: flex; align-items: center; gap: 8px; }
        .top-bar-title i { color: var(--accent-green); }
        .top-bar-divider { width: 1px; height: 24px; background: #333; margin: 0 8px; }
        .top-bar-info { font-size: 12px; color: var(--text-sub); }
        .top-bar-tools { display: flex; gap: 4px; margin-left: auto; }
        .top-tool-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; color: #888; background: transparent; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-size: 14px; }
        .top-tool-btn:hover { background: #2a2a2a; color: #fff; }

        .filter-panel { position: fixed; top: 48px; left: 0; width: 280px; height: calc(100vh - 48px); background: var(--panel-bg); border-right: 1px solid var(--border-color); z-index: 150; transition: transform 0.3s ease; overflow-y: auto; }
        .filter-panel.collapsed { transform: translateX(-280px); }
        .filter-toggle { position: fixed; top: 60px; left: 0; width: 28px; height: 48px; background: var(--panel-bg); border: 1px solid var(--border-color); border-left: none; border-radius: 0 8px 8px 0; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 151; transition: left 0.3s ease; color: var(--text-sub); }
        .filter-toggle:hover { color: #fff; background: #2a2a35; }
        .filter-panel:not(.collapsed) + .filter-toggle { left: 280px; }
        .filter-section { padding: 16px; border-bottom: 1px solid var(--border-color); }
        .filter-section-title { font-size: 11px; font-weight: 600; color: var(--text-sub); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .filter-section-title i { font-size: 12px; }
        .filter-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-row:last-child { margin-bottom: 0; }
        .filter-label { font-size: 12px; color: var(--text-main); display: flex; align-items: center; gap: 6px; }
        .filter-label .dot { width: 8px; height: 8px; border-radius: 50%; }
        .filter-input-group { display: flex; align-items: center; gap: 6px; }
        .filter-input { width: 70px; height: 28px; background: #1a1a1d; border: 1px solid var(--border-color); border-radius: 4px; color: #fff; font-size: 12px; text-align: center; padding: 0 6px; }
        .filter-input:focus { border-color: var(--accent-green); }
        .filter-sep { color: var(--text-sub); font-size: 12px; }
        .filter-toggle-switch { position: relative; width: 36px; height: 20px; background: #333; border-radius: 10px; cursor: pointer; transition: background 0.2s; }
        .filter-toggle-switch.active { background: var(--accent-green); }
        .filter-toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 50%; transition: transform 0.2s; }
        .filter-toggle-switch.active::after { transform: translateX(16px); }
        .filter-btn { width: 100%; height: 36px; background: var(--accent-green); color: #fff; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; margin-top: 12px; }
        .filter-btn:hover { opacity: 0.9; }

        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 11px; color: var(--text-sub); }
        .legend-item:last-child { margin-bottom: 0; }
        .legend-line { width: 24px; height: 2px; border-radius: 1px; }

        .detail-panel { position: fixed; bottom: 16px; right: 16px; width: 320px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; z-index: 100; transform: translateY(120%); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .detail-panel.active { transform: translateY(0); }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .panel-title { font-size: 12px; font-weight: 600; color: var(--text-sub); text-transform: uppercase; }
        .close-btn { cursor: pointer; padding: 4px; color: var(--text-sub); }
        .close-btn:hover { color: #fff; }
        .data-row { margin-bottom: 10px; }
        .data-label { font-size: 11px; color: var(--text-sub); margin-bottom: 4px; }
        .data-value { font-size: 12px; color: #fff; font-family: 'Roboto Mono', monospace; word-break: break-all; line-height: 1.4; }
        .action-btn { display: block; width: 100%; text-align: center; background: rgba(79, 162, 138, 0.15); color: var(--accent-green); padding: 10px; border-radius: 6px; text-decoration: none; font-size: 12px; margin-top: 12px; border: 1px solid rgba(79, 162, 138, 0.3); transition: 0.2s; }
        .action-btn:hover { background: rgba(79, 162, 138, 0.25); }

        #loading { position: fixed; inset: 0; background: var(--bg-color); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 999; transition: opacity 0.5s; }
        .spinner { width: 36px; height: 36px; border: 3px solid rgba(255,255,255,0.1); border-top-color: var(--accent-green); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hide { opacity: 0; pointer-events: none; }
        .toast { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 6px; border: 1px solid #333; z-index: 1001; display: none; text-align: center; font-size: 12px; }
        .toast.show { display: block; }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="top-bar-title"><i class="fas fa-project-diagram"></i> Ë≥áÈáëÊµÅÂêëËøΩËπ§</div>
        <div class="top-bar-divider"></div>
        <div class="top-bar-info" id="topInfo">ËºâÂÖ•‰∏≠...</div>
        <div class="top-bar-tools">
            <button class="top-tool-btn" id="zoomIn" title="ÊîæÂ§ß"><i class="fas fa-plus"></i></button>
            <button class="top-tool-btn" id="zoomOut" title="Á∏ÆÂ∞è"><i class="fas fa-minus"></i></button>
            <button class="top-tool-btn" id="fitScreen" title="ÈÅ©ÊáâÁï´Èù¢"><i class="fas fa-compress-arrows-alt"></i></button>
            <button class="top-tool-btn" id="resetView" title="ÈáçÁΩÆ"><i class="fas fa-redo"></i></button>
        </div>
    </div>

    <div class="filter-panel" id="filterPanel">
        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-filter"></i> ÈñæÂÄºÁØ©ÈÅ∏</div>
            <div class="filter-row">
                <div class="filter-label"><div class="dot" style="background: var(--accent-green);"></div> USDT</div>
                <div class="filter-toggle-switch active" id="toggleUsdt" title="È°ØÁ§∫/Èö±Ëóè USDT"></div>
            </div>
            <div class="filter-row">
                <div class="filter-input-group">
                    <input type="number" class="filter-input" id="usdtMin" placeholder="ÊúÄÂ∞è" value="1">
                    <span class="filter-sep">~</span>
                    <input type="number" class="filter-input" id="usdtMax" placeholder="ÊúÄÂ§ß" value="0">
                </div>
            </div>
            <div class="filter-row" style="margin-top: 16px;">
                <div class="filter-label"><div class="dot" style="background: var(--accent-red);"></div> TRX</div>
                <div class="filter-toggle-switch active" id="toggleTrx" title="È°ØÁ§∫/Èö±Ëóè TRX"></div>
            </div>
            <div class="filter-row">
                <div class="filter-input-group">
                    <input type="number" class="filter-input" id="trxMin" placeholder="ÊúÄÂ∞è" value="1">
                    <span class="filter-sep">~</span>
                    <input type="number" class="filter-input" id="trxMax" placeholder="ÊúÄÂ§ß" value="0">
                </div>
            </div>
            <button class="filter-btn" id="applyFilter"><i class="fas fa-check"></i> Â•óÁî®ÁØ©ÈÅ∏</button>
        </div>

        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-info-circle"></i> Âúñ‰æãË™™Êòé</div>
            <div class="legend-item"><div class="dot" style="background: var(--gold); box-shadow: 0 0 6px var(--gold);"></div> ÁõÆÊ®ôÂú∞ÂùÄ</div>
            <div class="legend-item"><div class="legend-line" style="background: var(--accent-green);"></div> USDT ËΩâÂ∏≥</div>
            <div class="legend-item"><div class="legend-line" style="background: var(--accent-red);"></div> TRX ËΩâÂ∏≥</div>
            <div class="legend-item" style="margin-top: 8px; font-size: 10px;">‚Üê ËΩâÂÖ•‰æÜÊ∫ê | ËΩâÂá∫ÂéªÂêë ‚Üí</div>
            <div class="legend-item" style="font-size: 10px; color: #555;">ÈõôÊìäÁØÄÈªûÂèØËøΩËπ§Ë©≤Âú∞ÂùÄ</div>
        </div>

        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-chart-bar"></i> Áµ±Ë®àË≥áË®ä</div>
            <div class="legend-item" id="statNodes">‰∫§ÊòìÊï∏Ôºö0</div>
            <div class="legend-item" id="statEdges">Âú∞ÂùÄÊï∏Ôºö0</div>
            <div class="legend-item" id="statUsdt">USDT Á∏ΩÈ°çÔºö0</div>
            <div class="legend-item" id="statTrx">TRX Á∏ΩÈ°çÔºö0</div>
        </div>
    </div>
    <div class="filter-toggle" id="filterToggle"><i class="fas fa-chevron-left"></i></div>

    <div class="detail-panel" id="detailPanel">
        <div class="panel-header">
            <div class="panel-title" id="panelType">ÁØÄÈªûË©≥ÊÉÖ</div>
            <div class="close-btn" onclick="closePanel()"><i class="fas fa-times"></i></div>
        </div>
        <div id="panelContent"></div>
        <a href="#" target="_blank" class="action-btn" id="panelLink">Âú® TronScan Êü•Áúã</a>
    </div>

    <div class="toast" id="toast"></div>
    <div id="loading"><div class="spinner"></div><div style="color: #666; font-size: 12px;">Ê≠£Âú®ÂàÜÊûêÈèà‰∏äÊï∏Êìö...</div></div>
    <div id="svgContainer"><svg id="svg"></svg></div>

    <script>
        // ================= Â∏∏Êï∏Ë®≠ÂÆö =================
        const NODE_WIDTH = 140;
        const NODE_HEIGHT = 32;
        const RANK_SEP = 200;  // Â±§Á¥öÈñìË∑ù
        const NODE_SEP = 50;   // ÁØÄÈªûÈñìË∑ù

        // ================= Ë®≠ÂÆö =================
        const CONFIG = (function() {
            const params = new URLSearchParams(window.location.search);
            return {
                ROOT_ADDRESS: params.get('address') || '',
                USDT_MIN: parseFloat(params.get('umin')) || 1,
                USDT_MAX: parseFloat(params.get('umax')) || 0,
                TRX_MIN: parseFloat(params.get('tmin')) || 1,
                TRX_MAX: parseFloat(params.get('tmax')) || 0
            };
        })();

        const FILTER = {
            showUsdt: true,
            showTrx: true,
            usdtMin: CONFIG.USDT_MIN,
            usdtMax: CONFIG.USDT_MAX,
            trxMin: CONFIG.TRX_MIN,
            trxMax: CONFIG.TRX_MAX
        };

        // ================= ÂúñË≥áÊñôÁµêÊßã =================
        const graphData = {
            nodes: new Map(),      // address -> nodeData
            edges: new Map(),      // edgeKey -> edgeData
            expandedCenters: new Set(),
            rawTransactions: []
        };

        // ================= Ë¶ñÂúñÊéßÂà∂ =================
        const view = {
            scale: 1,
            x: 0,
            y: 0,
            minScale: 0.1,
            maxScale: 5,
            velocityX: 0,
            velocityY: 0,
            friction: 0.92,
            animationId: null
        };

        // ================= ÂàùÂßãÂåñ =================
        async function init() {
            if (!CONFIG.ROOT_ADDRESS) {
                document.getElementById('loading').classList.add('hide');
                showToast('Ë´ãÊèê‰æõ address ÂèÉÊï∏');
                return;
            }

            document.getElementById('usdtMin').value = FILTER.usdtMin;
            document.getElementById('usdtMax').value = FILTER.usdtMax || '';
            document.getElementById('trxMin').value = FILTER.trxMin;
            document.getElementById('trxMax').value = FILTER.trxMax || '';

            // Â∑•ÂÖ∑Âàó‰∫ã‰ª∂
            document.getElementById('zoomIn').onclick = () => zoom(1.3);
            document.getElementById('zoomOut').onclick = () => zoom(0.77);
            document.getElementById('fitScreen').onclick = fitScreen;
            document.getElementById('resetView').onclick = resetAndReload;
            document.getElementById('filterToggle').onclick = toggleFilterPanel;

            document.getElementById('toggleUsdt').onclick = function() {
                this.classList.toggle('active');
                FILTER.showUsdt = this.classList.contains('active');
                render();
            };
            document.getElementById('toggleTrx').onclick = function() {
                this.classList.toggle('active');
                FILTER.showTrx = this.classList.contains('active');
                render();
            };
            document.getElementById('applyFilter').onclick = function() {
                FILTER.usdtMin = parseFloat(document.getElementById('usdtMin').value) || 0;
                FILTER.usdtMax = parseFloat(document.getElementById('usdtMax').value) || 0;
                FILTER.trxMin = parseFloat(document.getElementById('trxMin').value) || 0;
                FILTER.trxMax = parseFloat(document.getElementById('trxMax').value) || 0;
                render();
                showToast('ÁØ©ÈÅ∏Â∑≤Â•óÁî®');
            };

            setupDragAndZoom();

            await loadData(CONFIG.ROOT_ADDRESS);
            document.getElementById('loading').classList.add('hide');
            updateTopInfo();
            fitScreen();
        }

        // ================= Ë≥áÊñôËºâÂÖ• =================
        async function loadData(addr, append = false) {
            const url = `/api/trace?address=${addr}&umin=${FILTER.usdtMin}&umax=${FILTER.usdtMax}&tmin=${FILTER.trxMin}&tmax=${FILTER.trxMax}`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                if (!data.edges || data.edges.length === 0) {
                    showToast('Ë©≤Âú∞ÂùÄÁÑ°Á¨¶ÂêàÊ¢ù‰ª∂ÁöÑ‰∫§Êòì');
                    return false;
                }

                // Ê®ôË®ò‰∏≠ÂøÉÂú∞ÂùÄ
                const newTx = data.edges.map(e => ({
                    ...e,
                    centerAddr: addr
                }));

                if (append) {
                    graphData.rawTransactions = [...graphData.rawTransactions, ...newTx];
                } else {
                    graphData.rawTransactions = newTx;
                    graphData.nodes.clear();
                    graphData.edges.clear();
                }

                graphData.expandedCenters.add(addr);
                buildGraph();
                render();
                return true;
            } catch (e) {
                console.error(e);
                showToast('ËºâÂÖ•Â§±Êïó');
                return false;
            }
        }

        // ================= Âª∫Á´ãÂúñÁµêÊßã =================
        function buildGraph() {
            graphData.nodes.clear();
            graphData.edges.clear();

            // ÁØ©ÈÅ∏‰∫§Êòì
            const filteredTx = graphData.rawTransactions.filter(tx => {
                const isUsdt = tx.token === 'USDT';
                const isTrx = tx.token === 'TRX';
                if (isUsdt && !FILTER.showUsdt) return false;
                if (isTrx && !FILTER.showTrx) return false;
                if (isUsdt) {
                    if (tx.rawAmount < FILTER.usdtMin) return false;
                    if (FILTER.usdtMax > 0 && tx.rawAmount > FILTER.usdtMax) return false;
                }
                if (isTrx) {
                    if (tx.rawAmount < FILTER.trxMin) return false;
                    if (FILTER.trxMax > 0 && tx.rawAmount > FILTER.trxMax) return false;
                }
                return true;
            });

            // Êî∂ÈõÜÊâÄÊúâÂú∞ÂùÄ
            const allAddresses = new Set();
            allAddresses.add(CONFIG.ROOT_ADDRESS);

            filteredTx.forEach(tx => {
                const fromAddr = cleanAddress(tx.from);
                const toAddr = cleanAddress(tx.to);
                allAddresses.add(fromAddr);
                allAddresses.add(toAddr);
            });

            // Âª∫Á´ãÁØÄÈªû
            allAddresses.forEach(addr => {
                graphData.nodes.set(addr, {
                    address: addr,
                    isTarget: addr === CONFIG.ROOT_ADDRESS,
                    isExpanded: graphData.expandedCenters.has(addr),
                    x: 0,
                    y: 0
                });
            });

            // Âª∫Á´ãÈÇäÔºàÂêà‰ΩµÂêåÊñπÂêëÂêåÂπ£Á®ÆÁöÑ‰∫§ÊòìÔºâ
            const edgeAggregator = new Map();

            filteredTx.forEach(tx => {
                const fromAddr = cleanAddress(tx.from);
                const toAddr = cleanAddress(tx.to);
                const edgeKey = `${fromAddr}->${toAddr}:${tx.token}`;

                if (!edgeAggregator.has(edgeKey)) {
                    edgeAggregator.set(edgeKey, {
                        from: fromAddr,
                        to: toAddr,
                        token: tx.token,
                        totalAmount: 0,
                        txList: []
                    });
                }

                const edge = edgeAggregator.get(edgeKey);
                edge.totalAmount += tx.rawAmount;
                if (tx.txList) {
                    edge.txList.push(...tx.txList);
                } else {
                    edge.txList.push({
                        amount: tx.rawAmount,
                        amountStr: tx.amount,
                        time: tx.time || '',
                        hash: tx.hash || ''
                    });
                }
            });

            graphData.edges = edgeAggregator;
        }

        function cleanAddress(addr) {
            if (!addr) return '';
            return addr.replace(/_center|_in|_out$/g, '');
        }

        // ================= Dagre ‰ΩàÂ±Ä =================
        function calculateLayout() {
            const g = new dagre.graphlib.Graph();

            g.setGraph({
                rankdir: 'LR',      // Â∑¶Âà∞Âè≥
                ranksep: RANK_SEP,  // Â±§Á¥öÈñìË∑ù
                nodesep: NODE_SEP,  // ÁØÄÈªûÈñìË∑ù
                marginx: 50,
                marginy: 50
            });

            g.setDefaultEdgeLabel(() => ({}));

            // Ê∑ªÂä†ÁØÄÈªû
            graphData.nodes.forEach((node, addr) => {
                g.setNode(addr, {
                    width: NODE_WIDTH,
                    height: NODE_HEIGHT,
                    label: addr
                });
            });

            // Ê∑ªÂä†ÈÇä
            graphData.edges.forEach((edge, key) => {
                g.setEdge(edge.from, edge.to, {
                    weight: Math.log10(edge.totalAmount + 1) + 1
                });
            });

            // Âü∑Ë°å‰ΩàÂ±Ä
            dagre.layout(g);

            // Êõ¥Êñ∞ÁØÄÈªû‰ΩçÁΩÆ
            g.nodes().forEach(addr => {
                const nodeData = g.node(addr);
                const node = graphData.nodes.get(addr);
                if (node && nodeData) {
                    node.x = nodeData.x - NODE_WIDTH / 2;
                    node.y = nodeData.y - NODE_HEIGHT / 2;
                }
            });

            // Ë®àÁÆóÁï´Â∏ÉÂ§ßÂ∞è
            let maxX = 0, maxY = 0;
            graphData.nodes.forEach(node => {
                maxX = Math.max(maxX, node.x + NODE_WIDTH + 100);
                maxY = Math.max(maxY, node.y + NODE_HEIGHT + 100);
            });

            return { width: Math.max(maxX, 800), height: Math.max(maxY, 600) };
        }

        // ================= SVG Áπ™Ë£Ω =================
        function render() {
            const svg = document.getElementById('svg');
            svg.innerHTML = '';

            if (graphData.nodes.size === 0) return;

            buildGraph();
            const { width, height } = calculateLayout();

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Âª∫Á´ã defs Áî®ÊñºÁÆ≠È†≠
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead-usdt" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" fill="var(--accent-green)"/>
                </marker>
                <marker id="arrowhead-trx" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" fill="var(--accent-red)"/>
                </marker>
            `;
            svg.appendChild(defs);

            // Áπ™Ë£ΩÈÇä
            const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            edgeGroup.setAttribute('class', 'edges');
            graphData.edges.forEach((edge, key) => drawEdge(edgeGroup, edge));
            svg.appendChild(edgeGroup);

            // Áπ™Ë£ΩÁØÄÈªû
            const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            nodeGroup.setAttribute('class', 'nodes');
            graphData.nodes.forEach((node, addr) => drawNode(nodeGroup, node));
            svg.appendChild(nodeGroup);

            updateStats();
        }

        function drawNode(parent, node) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node-group');

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', node.x);
            rect.setAttribute('y', node.y);
            rect.setAttribute('width', NODE_WIDTH);
            rect.setAttribute('height', NODE_HEIGHT);
            rect.setAttribute('rx', 4);

            let boxClass = 'node-box';
            let textClass = 'node-text';
            if (node.isTarget) {
                boxClass += ' target';
                textClass += ' target';
            } else if (node.isExpanded) {
                boxClass += ' expanded';
                textClass += ' expanded';
            }
            rect.setAttribute('class', boxClass);
            rect.onclick = () => handleNodeClick(node);
            rect.ondblclick = () => handleNodeDblClick(node);
            g.appendChild(rect);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x + NODE_WIDTH / 2);
            text.setAttribute('y', node.y + NODE_HEIGHT / 2 + 4);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('class', textClass);
            const shortAddr = node.address.slice(0, 6) + '...' + node.address.slice(-4);
            text.textContent = node.isTarget ? 'üéØ ' + shortAddr : shortAddr;
            g.appendChild(text);

            parent.appendChild(g);
        }

        function drawEdge(parent, edge) {
            const fromNode = graphData.nodes.get(edge.from);
            const toNode = graphData.nodes.get(edge.to);
            if (!fromNode || !toNode) return;

            const tokenClass = edge.token === 'USDT' ? 'usdt' : 'trx';

            // Ë®àÁÆóËµ∑ÈªûÂíåÁµÇÈªû
            const startX = fromNode.x + NODE_WIDTH;
            const startY = fromNode.y + NODE_HEIGHT / 2;
            const endX = toNode.x;
            const endY = toNode.y + NODE_HEIGHT / 2;

            // Ë®àÁÆóÊéßÂà∂ÈªûÔºàË≤ùËå≤Êõ≤Á∑öÔºâ
            const midX = (startX + endX) / 2;
            const dx = endX - startX;
            const cpOffset = Math.min(Math.abs(dx) * 0.3, 100);

            // Áπ™Ë£ΩÊõ≤Á∑ö
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${startX} ${startY} C ${startX + cpOffset} ${startY}, ${endX - cpOffset} ${endY}, ${endX - 8} ${endY}`;
            path.setAttribute('d', d);
            path.setAttribute('class', `edge-path ${tokenClass}`);
            path.setAttribute('marker-end', `url(#arrowhead-${tokenClass})`);
            parent.appendChild(path);

            // Áπ™Ë£ΩÊ®ôÁ±§
            const labelX = midX;
            const labelY = (startY + endY) / 2;
            const labelText = formatNumber(edge.totalAmount) + ' ' + edge.token;
            if (edge.txList.length > 1) {
                labelText + ` (${edge.txList.length}Á≠Ü)`;
            }

            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = labelText.length * 6 + 8;
            labelBg.setAttribute('x', labelX - textWidth / 2);
            labelBg.setAttribute('y', labelY - 10);
            labelBg.setAttribute('width', textWidth);
            labelBg.setAttribute('height', 16);
            labelBg.setAttribute('class', 'label-bg');
            labelBg.onclick = () => handleEdgeClick(edge);
            parent.appendChild(labelBg);

            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY + 3);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('class', `label-text ${tokenClass}`);
            label.textContent = labelText;
            label.onclick = () => handleEdgeClick(edge);
            parent.appendChild(label);
        }

        // ================= ‰∫ã‰ª∂ËôïÁêÜ =================
        function handleNodeClick(node) {
            const panel = document.getElementById('detailPanel');
            const content = document.getElementById('panelContent');
            const linkBtn = document.getElementById('panelLink');
            const typeLabel = document.getElementById('panelType');

            if (node.isTarget) {
                typeLabel.textContent = 'üéØ ÁõÆÊ®ôÂú∞ÂùÄ';
                content.innerHTML = `<div class="data-row"><div class="data-label">Âú∞ÂùÄ</div><div class="data-value" style="color: #f0b90b">${node.address}</div></div>`;
            } else {
                typeLabel.textContent = 'üìç Âú∞ÂùÄË©≥ÊÉÖ';
                const status = node.isExpanded ? 'Â∑≤Â±ïÈñã' : 'ÈªûÊìäÂÖ©‰∏ãÂ±ïÈñã';
                content.innerHTML = `
                    <div class="data-row"><div class="data-label">Âú∞ÂùÄ</div><div class="data-value" style="color: #4fa28a">${node.address}</div></div>
                    <div class="data-row"><div class="data-label">ÁãÄÊÖã</div><div class="data-value">${status}</div></div>
                `;
            }
            linkBtn.href = 'https://tronscan.org/#/address/' + node.address;
            linkBtn.style.display = 'block';
            panel.classList.add('active');
        }

        async function handleNodeDblClick(node) {
            if (graphData.expandedCenters.has(node.address)) {
                showToast('Ê≠§ÁØÄÈªûÂ∑≤Â±ïÈñã');
                return;
            }

            showToast('ËºâÂÖ• ' + node.address.slice(0, 8) + '...');
            const success = await loadData(node.address, true);
            if (success) {
                showToast('Â∑≤Â±ïÈñã');
            }
        }

        function handleEdgeClick(edge) {
            const panel = document.getElementById('detailPanel');
            const content = document.getElementById('panelContent');
            const linkBtn = document.getElementById('panelLink');
            const typeLabel = document.getElementById('panelType');

            typeLabel.textContent = 'üí∏ ‰∫§ÊòìË©≥ÊÉÖ';

            let txListHtml = '';
            if (edge.txList && edge.txList.length > 0) {
                edge.txList.slice(0, 10).forEach((t, i) => {
                    const hashLink = t.hash
                        ? `<a href="https://tronscan.org/#/transaction/${t.hash}" target="_blank" style="color:#4fa28a;text-decoration:none;font-size:10px;">Êü•Áúã</a>`
                        : '';
                    txListHtml += `<div style="padding:6px 0;border-bottom:1px solid #2a2a2a;">
                        <div style="display:flex;justify-content:space-between;">
                            <span style="color:${edge.token === 'USDT' ? '#4fa28a' : '#ba3029'}">${t.amountStr || formatNumber(t.amount) + ' ' + edge.token}</span>
                            ${hashLink}
                        </div>
                        <div style="font-size:10px;color:#666;margin-top:2px;">${t.time || ''}</div>
                    </div>`;
                });
                if (edge.txList.length > 10) {
                    txListHtml += `<div style="padding:6px 0;color:#666;font-size:10px;">...ÈÇÑÊúâ ${edge.txList.length - 10} Á≠Ü</div>`;
                }
            }

            content.innerHTML = `
                <div class="data-row"><div class="data-label">Á∏ΩÈáëÈ°ç</div><div class="data-value" style="color: ${edge.token === 'USDT' ? '#4fa28a' : '#ba3029'}">${formatNumber(edge.totalAmount)} ${edge.token}</div></div>
                <div class="data-row"><div class="data-label">‰∫§ÊòìÁ≠ÜÊï∏</div><div class="data-value">${edge.txList.length} Á≠Ü</div></div>
                <div class="data-row"><div class="data-label">‰æÜÊ∫ê</div><div class="data-value" style="font-size:10px;">${edge.from}</div></div>
                <div class="data-row"><div class="data-label">ÁõÆÊ®ô</div><div class="data-value" style="font-size:10px;">${edge.to}</div></div>
                <div class="data-row"><div class="data-label">ÊòéÁ¥∞</div><div style="max-height:150px;overflow-y:auto;">${txListHtml || '<span style="color:#666">ÁÑ°</span>'}</div></div>
            `;
            linkBtn.style.display = 'none';
            panel.classList.add('active');
        }

        function closePanel() {
            document.getElementById('detailPanel').classList.remove('active');
        }

        // ================= Ë¶ñÂúñÊéßÂà∂ =================
        function setupDragAndZoom() {
            const container = document.getElementById('svgContainer');
            const svg = document.getElementById('svg');

            let isDragging = false;
            let lastX = 0, lastY = 0;

            function updateTransform() {
                svg.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
            }

            container.addEventListener('mousedown', e => {
                if (e.target.closest('.node-box, .label-text, .label-bg')) return;
                e.preventDefault();
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                container.classList.add('dragging');
            });

            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                e.preventDefault();
                view.x += e.clientX - lastX;
                view.y += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                updateTransform();
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                container.classList.remove('dragging');
            });

            container.addEventListener('click', e => {
                if (e.target === svg || e.target.tagName === 'svg') {
                    closePanel();
                }
            });

            container.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const svgX = (mouseX - view.x) / view.scale;
                const svgY = (mouseY - view.y) / view.scale;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * zoomFactor));
                view.x = mouseX - svgX * newScale;
                view.y = mouseY - svgY * newScale;
                view.scale = newScale;
                updateTransform();
            }, { passive: false });

            updateTransform();
        }

        function zoom(factor) {
            const container = document.getElementById('svgContainer');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const svgX = (centerX - view.x) / view.scale;
            const svgY = (centerY - view.y) / view.scale;
            const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * factor));
            view.x = centerX - svgX * newScale;
            view.y = centerY - svgY * newScale;
            view.scale = newScale;
            document.getElementById('svg').style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        }

        function fitScreen() {
            const container = document.getElementById('svgContainer');
            const svg = document.getElementById('svg');
            const svgWidth = parseInt(svg.getAttribute('width')) || 800;
            const svgHeight = parseInt(svg.getAttribute('height')) || 600;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const scaleX = containerWidth / svgWidth;
            const scaleY = containerHeight / svgHeight;
            view.scale = Math.min(scaleX, scaleY, 1) * 0.85;
            view.x = (containerWidth - svgWidth * view.scale) / 2;
            view.y = (containerHeight - svgHeight * view.scale) / 2;
            svg.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        }

        function toggleFilterPanel() {
            const panel = document.getElementById('filterPanel');
            const toggle = document.getElementById('filterToggle');
            const isCollapsed = panel.classList.toggle('collapsed');
            document.body.classList.toggle('panel-collapsed', isCollapsed);
            toggle.innerHTML = isCollapsed ? '<i class="fas fa-chevron-right"></i>' : '<i class="fas fa-chevron-left"></i>';
        }

        async function resetAndReload() {
            graphData.rawTransactions = [];
            graphData.expandedCenters = new Set();
            graphData.nodes.clear();
            graphData.edges.clear();
            closePanel();
            document.getElementById('loading').classList.remove('hide');
            await loadData(CONFIG.ROOT_ADDRESS);
            document.getElementById('loading').classList.add('hide');
            fitScreen();
        }

        // ================= ËºîÂä©ÂáΩÊï∏ =================
        function updateStats() {
            let usdtTotal = 0, trxTotal = 0;
            graphData.edges.forEach(edge => {
                if (edge.token === 'USDT') usdtTotal += edge.totalAmount;
                else if (edge.token === 'TRX') trxTotal += edge.totalAmount;
            });

            document.getElementById('statNodes').textContent = 'Âú∞ÂùÄÊï∏Ôºö' + graphData.nodes.size;
            document.getElementById('statEdges').textContent = '‰∫§ÊòìÈÇäÔºö' + graphData.edges.size;
            document.getElementById('statUsdt').textContent = 'USDT Á∏ΩÈ°çÔºö' + formatNumber(usdtTotal);
            document.getElementById('statTrx').textContent = 'TRX Á∏ΩÈ°çÔºö' + formatNumber(trxTotal);
        }

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        function updateTopInfo() {
            const shortAddr = CONFIG.ROOT_ADDRESS.slice(0, 8) + '...' + CONFIG.ROOT_ADDRESS.slice(-6);
            document.getElementById('topInfo').textContent = shortAddr;
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerHTML = msg;
            toast.className = 'toast show';
            setTimeout(() => { toast.className = 'toast'; }, 3000);
        }

        init();
    </script>
</body>
</html>
