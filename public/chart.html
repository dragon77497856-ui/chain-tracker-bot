<!DOCTYPE html>
<html>
<head>
    <title>è³‡é‡‘æµå‘è¿½è¹¤</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root { --bg-color: #1a1a1d; --panel-bg: rgba(30, 30, 35, 0.95); --border-color: #33333a; --accent-green: #4fa28a; --accent-red: #ba3029; --text-main: #e0e0e0; --text-sub: #888890; --gold: #f0b90b; }
        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; }
        body { background: var(--bg-color); color: var(--text-main); font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; }

        #svgContainer {
            width: 100vw; height: calc(100vh - 48px); margin-top: 48px;
            overflow: hidden; cursor: grab;
            -webkit-overflow-scrolling: touch;
            touch-action: none;
        }
        #svgContainer.dragging { cursor: grabbing; }
        body:not(.panel-collapsed) #svgContainer { margin-left: 280px; width: calc(100vw - 280px); }
        body.panel-collapsed #svgContainer { margin-left: 0; width: 100vw; }

        svg {
            display: block;
            will-change: transform;
            transform-origin: 0 0;
        }
        .node-box { fill: #1e1e24; stroke: #3a3a42; stroke-width: 1; cursor: pointer; }
        .node-box:hover { stroke: var(--accent-green); }
        .node-box.target { fill: rgba(240, 185, 11, 0.15); stroke: var(--gold); stroke-width: 2; }
        .node-box.expanded { fill: rgba(79, 162, 138, 0.15); stroke: var(--accent-green); stroke-width: 2; }
        .node-text { fill: #aaa; font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; pointer-events: none; }
        .node-text.target { fill: var(--gold); }
        .node-text.expanded { fill: var(--accent-green); }

        .edge-path { fill: none; stroke-width: 1.5; }
        .edge-path.usdt { stroke: var(--accent-green); }
        .edge-path.trx { stroke: var(--accent-red); }
        .edge-arrow { stroke: none; }
        .edge-arrow.usdt { fill: var(--accent-green); }
        .edge-arrow.trx { fill: var(--accent-red); }

        .label-text { font-family: 'Inter', sans-serif; font-size: 10px; pointer-events: auto; cursor: pointer; }
        .label-text:hover { filter: brightness(1.3); }
        .label-text.usdt { fill: var(--accent-green); }
        .label-text.trx { fill: var(--accent-red); }
        .label-bg { fill: rgba(26, 26, 29, 0.9); cursor: pointer; }
        .label-bg:hover { fill: rgba(40, 40, 45, 0.95); }

        .top-bar { position: fixed; top: 0; left: 0; right: 0; height: 48px; background: #0d0d0d; border-bottom: 1px solid #2a2a2a; display: flex; align-items: center; padding: 0 16px; gap: 12px; z-index: 200; }
        .top-bar-title { font-size: 14px; font-weight: 600; color: #fff; display: flex; align-items: center; gap: 8px; }
        .top-bar-title i { color: var(--accent-green); }
        .top-bar-divider { width: 1px; height: 24px; background: #333; margin: 0 8px; }
        .top-bar-info { font-size: 12px; color: var(--text-sub); }
        .top-bar-tools { display: flex; gap: 4px; margin-left: auto; }
        .top-tool-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; color: #888; background: transparent; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-size: 14px; }
        .top-tool-btn:hover { background: #2a2a2a; color: #fff; }

        .filter-panel { position: fixed; top: 48px; left: 0; width: 280px; height: calc(100vh - 48px); background: var(--panel-bg); border-right: 1px solid var(--border-color); z-index: 150; transition: transform 0.3s ease; overflow-y: auto; }
        .filter-panel.collapsed { transform: translateX(-280px); }
        .filter-toggle { position: fixed; top: 60px; left: 0; width: 28px; height: 48px; background: var(--panel-bg); border: 1px solid var(--border-color); border-left: none; border-radius: 0 8px 8px 0; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 151; transition: left 0.3s ease; color: var(--text-sub); }
        .filter-toggle:hover { color: #fff; background: #2a2a35; }
        .filter-panel:not(.collapsed) + .filter-toggle { left: 280px; }
        .filter-section { padding: 16px; border-bottom: 1px solid var(--border-color); }
        .filter-section-title { font-size: 11px; font-weight: 600; color: var(--text-sub); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .filter-section-title i { font-size: 12px; }
        .filter-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-row:last-child { margin-bottom: 0; }
        .filter-label { font-size: 12px; color: var(--text-main); display: flex; align-items: center; gap: 6px; }
        .filter-label .dot { width: 8px; height: 8px; border-radius: 50%; }
        .filter-input-group { display: flex; align-items: center; gap: 6px; }
        .filter-input { width: 70px; height: 28px; background: #1a1a1d; border: 1px solid var(--border-color); border-radius: 4px; color: #fff; font-size: 12px; text-align: center; padding: 0 6px; }
        .filter-input:focus { border-color: var(--accent-green); }
        .filter-sep { color: var(--text-sub); font-size: 12px; }
        .filter-toggle-switch { position: relative; width: 36px; height: 20px; background: #333; border-radius: 10px; cursor: pointer; transition: background 0.2s; }
        .filter-toggle-switch.active { background: var(--accent-green); }
        .filter-toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 50%; transition: transform 0.2s; }
        .filter-toggle-switch.active::after { transform: translateX(16px); }
        .filter-btn { width: 100%; height: 36px; background: var(--accent-green); color: #fff; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; margin-top: 12px; }
        .filter-btn:hover { opacity: 0.9; }

        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 11px; color: var(--text-sub); }
        .legend-item:last-child { margin-bottom: 0; }
        .legend-line { width: 24px; height: 2px; border-radius: 1px; }

        .detail-panel { position: fixed; bottom: 16px; right: 16px; width: 320px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; z-index: 100; transform: translateY(120%); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .detail-panel.active { transform: translateY(0); }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .panel-title { font-size: 12px; font-weight: 600; color: var(--text-sub); text-transform: uppercase; }
        .close-btn { cursor: pointer; padding: 4px; color: var(--text-sub); }
        .close-btn:hover { color: #fff; }
        .data-row { margin-bottom: 10px; }
        .data-label { font-size: 11px; color: var(--text-sub); margin-bottom: 4px; }
        .data-value { font-size: 12px; color: #fff; font-family: 'Roboto Mono', monospace; word-break: break-all; line-height: 1.4; }
        .action-btn { display: block; width: 100%; text-align: center; background: rgba(79, 162, 138, 0.15); color: var(--accent-green); padding: 10px; border-radius: 6px; text-decoration: none; font-size: 12px; margin-top: 12px; border: 1px solid rgba(79, 162, 138, 0.3); transition: 0.2s; }
        .action-btn:hover { background: rgba(79, 162, 138, 0.25); }

        #loading { position: fixed; inset: 0; background: var(--bg-color); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 999; transition: opacity 0.5s; }
        .spinner { width: 36px; height: 36px; border: 3px solid rgba(255,255,255,0.1); border-top-color: var(--accent-green); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hide { opacity: 0; pointer-events: none; }
        .toast { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 6px; border: 1px solid #333; z-index: 1001; display: none; text-align: center; font-size: 12px; }
        .toast.show { display: block; }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="top-bar-title"><i class="fas fa-project-diagram"></i> è³‡é‡‘æµå‘è¿½è¹¤</div>
        <div class="top-bar-divider"></div>
        <div class="top-bar-info" id="topInfo">è¼‰å…¥ä¸­...</div>
        <div class="top-bar-tools">
            <button class="top-tool-btn" id="zoomIn" title="æ”¾å¤§"><i class="fas fa-plus"></i></button>
            <button class="top-tool-btn" id="zoomOut" title="ç¸®å°"><i class="fas fa-minus"></i></button>
            <button class="top-tool-btn" id="fitScreen" title="é©æ‡‰ç•«é¢"><i class="fas fa-compress-arrows-alt"></i></button>
            <button class="top-tool-btn" id="resetView" title="é‡ç½®"><i class="fas fa-redo"></i></button>
        </div>
    </div>

    <div class="filter-panel" id="filterPanel">
        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-filter"></i> é–¾å€¼ç¯©é¸</div>
            <div class="filter-row">
                <div class="filter-label"><div class="dot" style="background: var(--accent-green);"></div> USDT</div>
                <div class="filter-toggle-switch active" id="toggleUsdt" title="é¡¯ç¤º/éš±è— USDT"></div>
            </div>
            <div class="filter-row">
                <div class="filter-input-group">
                    <input type="number" class="filter-input" id="usdtMin" placeholder="æœ€å°" value="1">
                    <span class="filter-sep">~</span>
                    <input type="number" class="filter-input" id="usdtMax" placeholder="æœ€å¤§" value="0">
                </div>
            </div>
            <div class="filter-row" style="margin-top: 16px;">
                <div class="filter-label"><div class="dot" style="background: var(--accent-red);"></div> TRX</div>
                <div class="filter-toggle-switch active" id="toggleTrx" title="é¡¯ç¤º/éš±è— TRX"></div>
            </div>
            <div class="filter-row">
                <div class="filter-input-group">
                    <input type="number" class="filter-input" id="trxMin" placeholder="æœ€å°" value="1">
                    <span class="filter-sep">~</span>
                    <input type="number" class="filter-input" id="trxMax" placeholder="æœ€å¤§" value="0">
                </div>
            </div>
            <button class="filter-btn" id="applyFilter"><i class="fas fa-check"></i> å¥—ç”¨ç¯©é¸</button>
        </div>

        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-info-circle"></i> åœ–ä¾‹èªªæ˜</div>
            <div class="legend-item"><div class="dot" style="background: var(--gold); box-shadow: 0 0 6px var(--gold);"></div> ç›®æ¨™åœ°å€</div>
            <div class="legend-item"><div class="legend-line" style="background: var(--accent-green);"></div> USDT è½‰å¸³</div>
            <div class="legend-item"><div class="legend-line" style="background: var(--accent-red);"></div> TRX è½‰å¸³</div>
            <div class="legend-item" style="margin-top: 8px; font-size: 10px;">â† è½‰å…¥ä¾†æº | è½‰å‡ºå»å‘ â†’</div>
            <div class="legend-item" style="font-size: 10px; color: #555;">é›™æ“Šç¯€é»å¯è¿½è¹¤è©²åœ°å€</div>
        </div>

        <div class="filter-section">
            <div class="filter-section-title"><i class="fas fa-chart-bar"></i> çµ±è¨ˆè³‡è¨Š</div>
            <div class="legend-item" id="statNodes">äº¤æ˜“æ•¸ï¼š0</div>
            <div class="legend-item" id="statEdges">åœ°å€æ•¸ï¼š0</div>
            <div class="legend-item" id="statUsdt">USDT ç¸½é¡ï¼š0</div>
            <div class="legend-item" id="statTrx">TRX ç¸½é¡ï¼š0</div>
        </div>
    </div>
    <div class="filter-toggle" id="filterToggle"><i class="fas fa-chevron-left"></i></div>

    <div class="detail-panel" id="detailPanel">
        <div class="panel-header">
            <div class="panel-title" id="panelType">ç¯€é»è©³æƒ…</div>
            <div class="close-btn" onclick="closePanel()"><i class="fas fa-times"></i></div>
        </div>
        <div id="panelContent"></div>
        <a href="#" target="_blank" class="action-btn" id="panelLink">åœ¨ TronScan æŸ¥çœ‹</a>
    </div>

    <div class="toast" id="toast"></div>
    <div id="loading"><div class="spinner"></div><div style="color: #666; font-size: 12px;">æ­£åœ¨åˆ†æéˆä¸Šæ•¸æ“š...</div></div>
    <div id="svgContainer"><svg id="svg"></svg></div>

    <script>
        // ================= å¸¸æ•¸è¨­å®š =================
        const NODE_WIDTH = 140;
        const NODE_HEIGHT = 32;
        const V_GAP = 22;           // æ¨™ç±¤å‚ç›´é–“è·
        const FORK_DIST = 80;       // åˆ†å²”é»è·é›¢
        const LEVEL_GAP = 400;      // å±¤ç´šé–“è·

        // ================= è¨­å®š =================
        const CONFIG = (function() {
            const params = new URLSearchParams(window.location.search);
            return {
                ROOT_ADDRESS: params.get('address') || '',
                USDT_MIN: parseFloat(params.get('umin')) || 1,
                USDT_MAX: parseFloat(params.get('umax')) || 0,
                TRX_MIN: parseFloat(params.get('tmin')) || 1,
                TRX_MAX: parseFloat(params.get('tmax')) || 0
            };
        })();

        const FILTER = {
            showUsdt: true,
            showTrx: true,
            usdtMin: CONFIG.USDT_MIN,
            usdtMax: CONFIG.USDT_MAX,
            trxMin: CONFIG.TRX_MIN,
            trxMax: CONFIG.TRX_MAX
        };

        // ================= å…¨åŸŸè®Šæ•¸ =================
        let rawTransactions = [];
        let expandedCenters = new Set();  // å·²å±•é–‹çš„ä¸­å¿ƒåœ°å€
        let nodeDataMap = {};  // å„²å­˜ç¯€é»è³‡æ–™ä¾›é»æ“Šä½¿ç”¨

        // ================= è¦–åœ–æ§åˆ¶ =================
        const view = {
            scale: 1,
            x: 0,
            y: 0,
            minScale: 0.1,
            maxScale: 5,
            // æ…£æ€§
            velocityX: 0,
            velocityY: 0,
            friction: 0.92,
            animationId: null
        };

        // ================= åˆå§‹åŒ– =================
        async function init() {
            if (!CONFIG.ROOT_ADDRESS) {
                document.getElementById('loading').classList.add('hide');
                showToast('âš ï¸ è«‹æä¾› address åƒæ•¸');
                return;
            }

            document.getElementById('usdtMin').value = FILTER.usdtMin;
            document.getElementById('usdtMax').value = FILTER.usdtMax || '';
            document.getElementById('trxMin').value = FILTER.trxMin;
            document.getElementById('trxMax').value = FILTER.trxMax || '';

            // å·¥å…·åˆ—äº‹ä»¶
            document.getElementById('zoomIn').onclick = zoomIn;
            document.getElementById('zoomOut').onclick = zoomOut;
            document.getElementById('fitScreen').onclick = fitScreen;
            document.getElementById('resetView').onclick = resetAndReload;
            document.getElementById('filterToggle').onclick = toggleFilterPanel;

            document.getElementById('toggleUsdt').onclick = function() {
                this.classList.toggle('active');
                FILTER.showUsdt = this.classList.contains('active');
                render();
            };
            document.getElementById('toggleTrx').onclick = function() {
                this.classList.toggle('active');
                FILTER.showTrx = this.classList.contains('active');
                render();
            };
            document.getElementById('applyFilter').onclick = function() {
                FILTER.usdtMin = parseFloat(document.getElementById('usdtMin').value) || 0;
                FILTER.usdtMax = parseFloat(document.getElementById('usdtMax').value) || 0;
                FILTER.trxMin = parseFloat(document.getElementById('trxMin').value) || 0;
                FILTER.trxMax = parseFloat(document.getElementById('trxMax').value) || 0;
                render();
                showToast('âœ… ç¯©é¸å·²å¥—ç”¨');
            };

            // æ‹–æ›³èˆ‡ç¸®æ”¾
            setupDragAndZoom();

            await loadData(CONFIG.ROOT_ADDRESS);
            document.getElementById('loading').classList.add('hide');
            updateTopInfo();
        }

        function setupDragAndZoom() {
            const container = document.getElementById('svgContainer');
            const svg = document.getElementById('svg');

            let isDragging = false;
            let lastX = 0, lastY = 0;
            let lastTime = 0;

            // æ›´æ–°è¦–åœ–è®Šæ›
            function updateTransform() {
                svg.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
            }

            // æ…£æ€§å‹•ç•«
            function inertiaAnimation() {
                if (Math.abs(view.velocityX) < 0.5 && Math.abs(view.velocityY) < 0.5) {
                    view.animationId = null;
                    return;
                }

                view.x += view.velocityX;
                view.y += view.velocityY;
                view.velocityX *= view.friction;
                view.velocityY *= view.friction;

                updateTransform();
                view.animationId = requestAnimationFrame(inertiaAnimation);
            }

            // åœæ­¢æ…£æ€§
            function stopInertia() {
                if (view.animationId) {
                    cancelAnimationFrame(view.animationId);
                    view.animationId = null;
                }
                view.velocityX = 0;
                view.velocityY = 0;
            }

            // æ»‘é¼ äº‹ä»¶
            container.addEventListener('mousedown', e => {
                if (e.target.closest('.node-box, .label-text, .label-bg')) return;
                e.preventDefault();
                stopInertia();
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                lastTime = Date.now();
                container.classList.add('dragging');
            });

            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                e.preventDefault();

                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                const now = Date.now();
                const dt = now - lastTime;

                view.x += dx;
                view.y += dy;

                // è¨ˆç®—é€Ÿåº¦ç”¨æ–¼æ…£æ€§
                if (dt > 0) {
                    view.velocityX = dx * 0.6;
                    view.velocityY = dy * 0.6;
                }

                lastX = e.clientX;
                lastY = e.clientY;
                lastTime = now;

                updateTransform();
            });

            window.addEventListener('mouseup', e => {
                if (!isDragging) return;
                isDragging = false;
                container.classList.remove('dragging');

                // å•Ÿå‹•æ…£æ€§å‹•ç•«
                if (Math.abs(view.velocityX) > 1 || Math.abs(view.velocityY) > 1) {
                    inertiaAnimation();
                }
            });

            // é»æ“Šç©ºç™½è™•é—œé–‰é¢æ¿
            container.addEventListener('click', e => {
                if (e.target === svg || e.target.tagName === 'svg') {
                    closePanel();
                }
            });

            // æ»¾è¼ªç¸®æ”¾
            container.addEventListener('wheel', e => {
                e.preventDefault();
                stopInertia();

                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // è¨ˆç®—æ»‘é¼ åœ¨ SVG åº§æ¨™ç³»ä¸­çš„ä½ç½®
                const svgX = (mouseX - view.x) / view.scale;
                const svgY = (mouseY - view.y) / view.scale;

                // æ›´å¹³æ»‘çš„ç¸®æ”¾å› å­
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * zoomFactor));

                // èª¿æ•´ä½ç½®è®“æ»‘é¼ æŒ‡å‘çš„é»ä¿æŒä¸è®Š
                view.x = mouseX - svgX * newScale;
                view.y = mouseY - svgY * newScale;
                view.scale = newScale;

                updateTransform();
            }, { passive: false });

            // è§¸æ§æ”¯æŒ
            let touchStartDist = 0;
            let touchStartScale = 1;
            let touchStartX = 0, touchStartY = 0;
            let touchStartViewX = 0, touchStartViewY = 0;

            container.addEventListener('touchstart', e => {
                stopInertia();
                if (e.touches.length === 1) {
                    // å–®æŒ‡æ‹–æ›³
                    isDragging = true;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    lastTime = Date.now();
                    touchStartX = lastX;
                    touchStartY = lastY;
                    touchStartViewX = view.x;
                    touchStartViewY = view.y;
                } else if (e.touches.length === 2) {
                    // é›™æŒ‡ç¸®æ”¾
                    isDragging = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDist = Math.sqrt(dx * dx + dy * dy);
                    touchStartScale = view.scale;
                    touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    touchStartViewX = view.x;
                    touchStartViewY = view.y;
                }
            }, { passive: true });

            container.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    const dx = e.touches[0].clientX - lastX;
                    const dy = e.touches[0].clientY - lastY;
                    const now = Date.now();
                    const dt = now - lastTime;

                    view.x += dx;
                    view.y += dy;

                    if (dt > 0) {
                        view.velocityX = dx * 0.6;
                        view.velocityY = dy * 0.6;
                    }

                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    lastTime = now;
                    updateTransform();
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    const rect = container.getBoundingClientRect();
                    const svgX = (touchStartX - rect.left - touchStartViewX) / touchStartScale;
                    const svgY = (touchStartY - rect.top - touchStartViewY) / touchStartScale;

                    const newScale = Math.max(view.minScale, Math.min(view.maxScale, touchStartScale * (dist / touchStartDist)));
                    view.scale = newScale;
                    view.x = centerX - rect.left - svgX * newScale;
                    view.y = centerY - rect.top - svgY * newScale;

                    updateTransform();
                }
            }, { passive: false });

            container.addEventListener('touchend', e => {
                if (e.touches.length === 0) {
                    isDragging = false;
                    if (Math.abs(view.velocityX) > 1 || Math.abs(view.velocityY) > 1) {
                        inertiaAnimation();
                    }
                }
            }, { passive: true });

            // åˆå§‹æ›´æ–°
            updateTransform();
        }

        function zoomIn(clientX, clientY) {
            const container = document.getElementById('svgContainer');
            const rect = container.getBoundingClientRect();
            const mouseX = clientX !== undefined ? clientX - rect.left : rect.width / 2;
            const mouseY = clientY !== undefined ? clientY - rect.top : rect.height / 2;

            const svgX = (mouseX - view.x) / view.scale;
            const svgY = (mouseY - view.y) / view.scale;

            const newScale = Math.min(view.maxScale, view.scale * 1.3);
            view.x = mouseX - svgX * newScale;
            view.y = mouseY - svgY * newScale;
            view.scale = newScale;

            document.getElementById('svg').style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        }

        function zoomOut(clientX, clientY) {
            const container = document.getElementById('svgContainer');
            const rect = container.getBoundingClientRect();
            const mouseX = clientX !== undefined ? clientX - rect.left : rect.width / 2;
            const mouseY = clientY !== undefined ? clientY - rect.top : rect.height / 2;

            const svgX = (mouseX - view.x) / view.scale;
            const svgY = (mouseY - view.y) / view.scale;

            const newScale = Math.max(view.minScale, view.scale / 1.3);
            view.x = mouseX - svgX * newScale;
            view.y = mouseY - svgY * newScale;
            view.scale = newScale;

            document.getElementById('svg').style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        }

        function fitScreen() {
            const container = document.getElementById('svgContainer');
            const svg = document.getElementById('svg');
            const svgWidth = parseInt(svg.getAttribute('width')) || 800;
            const svgHeight = parseInt(svg.getAttribute('height')) || 600;

            // è¨ˆç®—é©åˆç•«é¢çš„ç¸®æ”¾æ¯”ä¾‹
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const scaleX = containerWidth / svgWidth;
            const scaleY = containerHeight / svgHeight;
            view.scale = Math.min(scaleX, scaleY, 1) * 0.9;

            // ç½®ä¸­
            view.x = (containerWidth - svgWidth * view.scale) / 2;
            view.y = (containerHeight - svgHeight * view.scale) / 2;

            svg.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
        }

        function toggleFilterPanel() {
            const panel = document.getElementById('filterPanel');
            const toggle = document.getElementById('filterToggle');
            const isCollapsed = panel.classList.toggle('collapsed');
            document.body.classList.toggle('panel-collapsed', isCollapsed);
            toggle.innerHTML = isCollapsed ? '<i class="fas fa-chevron-right"></i>' : '<i class="fas fa-chevron-left"></i>';
        }

        // ================= è³‡æ–™è¼‰å…¥ =================
        async function loadData(addr, append = false) {
            const url = `/api/trace?address=${addr}&umin=${FILTER.usdtMin}&umax=${FILTER.usdtMax}&tmin=${FILTER.trxMin}&tmax=${FILTER.trxMax}`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                if (!data.edges || data.edges.length === 0) {
                    showToast('âš ï¸ è©²åœ°å€ç„¡ç¬¦åˆæ¢ä»¶çš„äº¤æ˜“');
                    return false;
                }
                const newTx = data.edges.map(e => ({
                    ...e,
                    centerAddr: addr
                }));
                if (append) {
                    rawTransactions = [...rawTransactions, ...newTx];
                } else {
                    rawTransactions = newTx;
                }
                expandedCenters.add(addr);
                render();
                return true;
            } catch (e) {
                console.error(e);
                showToast('âŒ è¼‰å…¥å¤±æ•—');
                return false;
            }
        }

        async function resetAndReload() {
            rawTransactions = [];
            expandedCenters = new Set();
            closePanel();
            document.getElementById('loading').classList.remove('hide');
            await loadData(CONFIG.ROOT_ADDRESS);
            document.getElementById('loading').classList.add('hide');
            fitScreen();
        }

        // ================= SVG ç¹ªè£½ =================
        const LABEL_HEIGHT = 16;  // æ¨™ç±¤é«˜åº¦ï¼ˆå«é–“è·ï¼‰
        const LABEL_MIN_GAP = 4;  // æ¨™ç±¤æœ€å°é–“è·

        function render() {
            const svg = document.getElementById('svg');
            svg.innerHTML = '';
            nodeDataMap = {};

            // ç¯©é¸äº¤æ˜“
            const filteredTx = rawTransactions.filter(tx => {
                const isUsdt = tx.token === 'USDT';
                const isTrx = tx.token === 'TRX';
                if (isUsdt && !FILTER.showUsdt) return false;
                if (isTrx && !FILTER.showTrx) return false;
                if (isUsdt) {
                    if (tx.rawAmount < FILTER.usdtMin) return false;
                    if (FILTER.usdtMax > 0 && tx.rawAmount > FILTER.usdtMax) return false;
                }
                if (isTrx) {
                    if (tx.rawAmount < FILTER.trxMin) return false;
                    if (FILTER.trxMax > 0 && tx.rawAmount > FILTER.trxMax) return false;
                }
                return true;
            });

            // è¨ˆç®—ä½ˆå±€
            const layout = calculateLayout(filteredTx);

            // è¨ˆç®—æ‰€æœ‰æ¨™ç±¤ä½ç½®ï¼ˆå«ç¢°æ’æª¢æ¸¬ï¼‰
            const labelPositions = calculateLabelPositions(layout);

            // æ ¹æ“šæ¨™ç±¤ä½ç½®èª¿æ•´ç•«å¸ƒé«˜åº¦
            let maxLabelY = layout.height;
            let minLabelY = 0;
            labelPositions.forEach(group => {
                group.forEach(y => {
                    if (y > maxLabelY - 50) maxLabelY = y + 50;
                    if (y < minLabelY + 50) minLabelY = y - 50;
                });
            });
            const adjustedHeight = Math.max(layout.height, maxLabelY);

            // è¨­å®š SVG å¤§å°
            svg.setAttribute('width', layout.width);
            svg.setAttribute('height', adjustedHeight);
            svg.setAttribute('viewBox', `0 0 ${layout.width} ${adjustedHeight}`);

            // å…ˆç•«é‚Šï¼Œå†ç•«ç¯€é»ï¼ˆç¯€é»åœ¨ä¸Šå±¤ï¼‰
            layout.edgeGroups.forEach((g, groupIdx) => {
                drawEdgeGroup(svg, g, labelPositions[groupIdx]);
            });
            Object.values(layout.nodes).forEach(n => drawNode(svg, n));

            updateStats(filteredTx);
        }

        // è¨ˆç®—æ‰€æœ‰æ¨™ç±¤ä½ç½®ï¼Œé¿å…é‡ç–Š
        function calculateLabelPositions(layout) {
            const allLabels = [];

            // ç¬¬ä¸€æ­¥ï¼šæ”¶é›†æ‰€æœ‰æ¨™ç±¤çš„ç†æƒ³ä½ç½®
            // åƒè€ƒ MetaSleuthï¼šæ¨™ç±¤ Y = å…©ç¯€é»çš„ä¸­é»ï¼Œå¤šç­†äº¤æ˜“åœç¹ä¸­é»åˆ†æ•£
            layout.edgeGroups.forEach((group, groupIdx) => {
                const centerNode = group.type === 'outflow' ? group.fromNode : group.toNode;
                const otherNode = group.type === 'outflow' ? group.toNode : group.fromNode;
                const sourceNode = group.type === 'outflow' ? centerNode : otherNode;
                const targetNode = group.type === 'outflow' ? otherNode : centerNode;

                const flowCount = group.flows.length;
                // å…©ç¯€é»çš„å‚ç›´ä¸­é»
                const midY = (sourceNode.y + targetNode.y) / 2 + NODE_HEIGHT / 2;

                group.flows.forEach((tx, flowIdx) => {
                    const timeStr = tx.txList?.[0]?.time || '';
                    const labelText = `[${timeStr}] ${tx.amount}`;
                    const labelW = labelText.length * 6;

                    // è¨ˆç®—æ¨™ç±¤çš„ X ç¯„åœ
                    const minX = Math.min(sourceNode.x, targetNode.x);
                    const maxX = Math.max(sourceNode.x, targetNode.x);

                    // ç†æƒ³ä½ç½®ï¼šåœç¹ä¸­é»åˆ†æ•£
                    const offsetY = (flowIdx - (flowCount - 1) / 2) * V_GAP;
                    const idealY = midY + offsetY;

                    allLabels.push({
                        groupIdx,
                        flowIdx,
                        idealY,
                        finalY: idealY,
                        labelW,
                        xRange: [minX, maxX + NODE_WIDTH]
                    });
                });
            });

            // ç¬¬äºŒæ­¥ï¼šç¢°æ’æª¢æ¸¬ - åªè™•ç† X ç¯„åœé‡ç–Šçš„æ¨™ç±¤
            // æŒ‰ idealY æ’åº
            allLabels.sort((a, b) => a.idealY - b.idealY);

            // è¿½è¹¤å·²ä½”ç”¨çš„ Y ä½ç½®
            const occupiedRanges = [];

            allLabels.forEach(label => {
                let y = label.idealY;
                let attempts = 0;
                const maxAttempts = 50;

                while (attempts < maxAttempts) {
                    let hasCollision = false;

                    for (const occupied of occupiedRanges) {
                        // æª¢æŸ¥ X ç¯„åœæ˜¯å¦é‡ç–Š
                        const xOverlap = !(label.xRange[1] < occupied.xMin || label.xRange[0] > occupied.xMax);
                        if (!xOverlap) continue;

                        // æª¢æŸ¥ Y ç¯„åœæ˜¯å¦é‡ç–Š
                        const yOverlap = Math.abs(y - occupied.y) < (LABEL_HEIGHT + LABEL_MIN_GAP);
                        if (yOverlap) {
                            hasCollision = true;
                            // å¾€ä¸‹ç§»å‹•
                            y = occupied.y + LABEL_HEIGHT + LABEL_MIN_GAP;
                            break;
                        }
                    }

                    if (!hasCollision) break;
                    attempts++;
                }

                label.finalY = y;
                occupiedRanges.push({
                    y: y,
                    xMin: label.xRange[0],
                    xMax: label.xRange[1]
                });
            });

            // ç¬¬ä¸‰æ­¥ï¼šæ•´ç†çµæœ
            const result = layout.edgeGroups.map(() => []);
            allLabels.forEach(label => {
                result[label.groupIdx][label.flowIdx] = label.finalY;
            });

            return result;
        }

        function calculateLayout(filteredTx) {
            const layout = { nodes: {}, edgeGroups: [], width: 0, height: 0 };

            // è¨ˆç®—æ¯å€‹åœ°å€ç›¸å°æ–¼å„ä¸­å¿ƒçš„æ·¨æµé‡
            // netFlow > 0 è¡¨ç¤ºè©²åœ°å€æ˜¯æ·¨æµå‡ºï¼ˆçµ¦ä¸­å¿ƒéŒ¢ï¼‰â†’ æ”¾å·¦å´
            // netFlow < 0 è¡¨ç¤ºè©²åœ°å€æ˜¯æ·¨æµå…¥ï¼ˆå¾ä¸­å¿ƒæ‹¿éŒ¢ï¼‰â†’ æ”¾å³å´
            const centerRelations = {};  // center -> { addr -> { inAmount, outAmount, txs } }

            filteredTx.forEach(tx => {
                const center = tx.centerAddr;
                const other = tx.direction === 'in'
                    ? tx.from.replace(/_center|_in|_out$/g, '')
                    : tx.to.replace(/_center|_in|_out$/g, '');

                if (!centerRelations[center]) centerRelations[center] = {};
                if (!centerRelations[center][other]) {
                    centerRelations[center][other] = { inAmount: 0, outAmount: 0, inTxs: [], outTxs: [] };
                }

                if (tx.direction === 'in') {
                    // å°æ–¹è½‰çµ¦ä¸­å¿ƒ = å°æ–¹æ˜¯ä¾†æº
                    centerRelations[center][other].inAmount += tx.rawAmount || 0;
                    centerRelations[center][other].inTxs.push(tx);
                } else {
                    // ä¸­å¿ƒè½‰çµ¦å°æ–¹ = å°æ–¹æ˜¯å»å‘
                    centerRelations[center][other].outAmount += tx.rawAmount || 0;
                    centerRelations[center][other].outTxs.push(tx);
                }
            });

            // BFS è¨ˆç®—æ¯å€‹åœ°å€çš„å±¤ç´šï¼ˆåŸºæ–¼æ·¨æµé‡ï¼‰
            const addrLevel = {};
            addrLevel[CONFIG.ROOT_ADDRESS] = 0;

            const queue = [CONFIG.ROOT_ADDRESS];
            const processed = new Set();

            while (queue.length > 0) {
                const center = queue.shift();
                if (processed.has(center)) continue;
                processed.add(center);

                const centerLvl = addrLevel[center] || 0;
                const relations = centerRelations[center];
                if (!relations) continue;

                Object.entries(relations).forEach(([addr, data]) => {
                    if (addrLevel[addr] !== undefined) return;

                    // æ·¨æµé‡ = æµå…¥ä¸­å¿ƒ - æµå‡ºä¸­å¿ƒ
                    const netFlow = data.inAmount - data.outAmount;

                    if (netFlow > 0) {
                        // å°æ–¹çµ¦ä¸­å¿ƒæ›´å¤š â†’ å°æ–¹æ˜¯ä¾†æº â†’ æ”¾å·¦å´
                        addrLevel[addr] = centerLvl - 1;
                    } else {
                        // ä¸­å¿ƒçµ¦å°æ–¹æ›´å¤š â†’ å°æ–¹æ˜¯å»å‘ â†’ æ”¾å³å´
                        addrLevel[addr] = centerLvl + 1;
                    }

                    if (expandedCenters.has(addr)) {
                        queue.push(addr);
                    }
                });
            }

            // æŒ‰å±¤ç´šåˆ†çµ„åœ°å€
            const levelGroups = {};
            Object.entries(addrLevel).forEach(([addr, lvl]) => {
                if (!levelGroups[lvl]) levelGroups[lvl] = [];
                levelGroups[lvl].push(addr);
            });

            // è¨ˆç®—å±¤ç´šç¯„åœ
            const levels = Object.keys(levelGroups).map(Number).sort((a, b) => a - b);
            if (levels.length === 0) return layout;

            const minLevel = Math.min(...levels);

            // è¨ˆç®—æœ€å¤§ç¯€é»æ•¸ï¼ˆç”¨æ–¼é«˜åº¦ï¼‰
            let maxNodesInLevel = 1;
            Object.values(levelGroups).forEach(addrs => {
                maxNodesInLevel = Math.max(maxNodesInLevel, addrs.length);
            });

            const totalHeight = Math.max(maxNodesInLevel * (NODE_HEIGHT + 40) + 100, 400);
            const centerY = totalHeight / 2;

            // å»ºç«‹ç¯€é»
            levels.forEach(lvl => {
                const addrs = levelGroups[lvl];
                const xPos = 50 + (lvl - minLevel) * (NODE_WIDTH + LEVEL_GAP);
                const startY = centerY - (addrs.length * (NODE_HEIGHT + 40)) / 2;

                addrs.forEach((addr, i) => {
                    const id = 'node_' + addr;
                    const short = addr.slice(0, 6) + '...' + addr.slice(-4);
                    const isRoot = addr === CONFIG.ROOT_ADDRESS;
                    const isExpanded = expandedCenters.has(addr);

                    layout.nodes[id] = {
                        id, address: addr,
                        label: isRoot ? 'ğŸ¯ ' + short : short,
                        x: xPos, y: startY + i * (NODE_HEIGHT + 40),
                        level: lvl,
                        isTarget: isRoot,
                        isExpanded,
                        isSource: lvl < addrLevel[CONFIG.ROOT_ADDRESS]
                    };
                    nodeDataMap[id] = { address: addr, isSource: lvl < 0, isExpanded };
                });
            });

            // å»ºç«‹é‚Šç¾¤çµ„ï¼ˆæŒ‰ç…§å¯¦éš›äº¤æ˜“æ–¹å‘ï¼‰
            Object.entries(centerRelations).forEach(([center, relations]) => {
                const centerNode = layout.nodes['node_' + center];
                if (!centerNode) return;

                Object.entries(relations).forEach(([addr, data]) => {
                    const otherNode = layout.nodes['node_' + addr];
                    if (!otherNode) return;

                    // å…¥å¸³é‚Šï¼ˆå°æ–¹ â†’ ä¸­å¿ƒï¼‰
                    if (data.inTxs.length > 0) {
                        const fromNode = otherNode;
                        const toNode = centerNode;
                        layout.edgeGroups.push({
                            type: 'inflow',
                            fromNode, toNode,
                            startX: fromNode.x + NODE_WIDTH,
                            startY: fromNode.y + NODE_HEIGHT / 2,
                            forkX: fromNode.x + NODE_WIDTH + FORK_DIST,
                            mergeX: toNode.x - FORK_DIST,
                            endX: toNode.x,
                            endY: toNode.y + NODE_HEIGHT / 2,
                            flows: data.inTxs
                        });
                    }

                    // å‡ºå¸³é‚Šï¼ˆä¸­å¿ƒ â†’ å°æ–¹ï¼‰
                    if (data.outTxs.length > 0) {
                        const fromNode = centerNode;
                        const toNode = otherNode;
                        layout.edgeGroups.push({
                            type: 'outflow',
                            fromNode, toNode,
                            startX: fromNode.x + NODE_WIDTH,
                            startY: fromNode.y + NODE_HEIGHT / 2,
                            forkX: fromNode.x + NODE_WIDTH + FORK_DIST,
                            mergeX: toNode.x - FORK_DIST,
                            endX: toNode.x,
                            endY: toNode.y + NODE_HEIGHT / 2,
                            flows: data.outTxs
                        });
                    }
                });
            });

            // è¨ˆç®—ç•«å¸ƒå¤§å°
            let maxX = 0, maxY = 0;
            Object.values(layout.nodes).forEach(n => {
                maxX = Math.max(maxX, n.x + NODE_WIDTH + 100);
                maxY = Math.max(maxY, n.y + NODE_HEIGHT + 50);
            });
            layout.width = maxX;
            layout.height = Math.max(maxY, totalHeight);

            return layout;
        }

        function drawNode(svg, node) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node-group');
            g.setAttribute('data-id', node.id);

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', node.x);
            rect.setAttribute('y', node.y);
            rect.setAttribute('width', NODE_WIDTH);
            rect.setAttribute('height', NODE_HEIGHT);
            rect.setAttribute('rx', 4);

            // è¨­å®šç¯€é»æ¨£å¼é¡åˆ¥
            let boxClass = 'node-box';
            let textClass = 'node-text';
            if (node.isTarget) {
                boxClass += ' target';
                textClass += ' target';
            } else if (node.isExpanded) {
                boxClass += ' expanded';
                textClass += ' expanded';
            }
            rect.setAttribute('class', boxClass);
            rect.setAttribute('data-id', node.id);
            rect.onclick = () => handleNodeClick(node);
            rect.ondblclick = () => handleNodeDblClick(node);
            g.appendChild(rect);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x + NODE_WIDTH / 2);
            text.setAttribute('y', node.y + NODE_HEIGHT / 2 + 4);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('class', textClass);
            text.textContent = node.label;
            g.appendChild(text);

            svg.appendChild(g);
        }

        function drawEdgeGroup(svg, group, labelYPositions) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const flows = group.flows;

            // ç¢ºå®šå“ªå€‹æ˜¯ä¸­å¿ƒç¯€é»ï¼Œå“ªå€‹æ˜¯ã€Œå…¶ä»–ã€ç¯€é»
            let centerNode, otherNode, isOutflow;
            if (group.type === 'outflow') {
                centerNode = group.fromNode;
                otherNode = group.toNode;
                isOutflow = true;
            } else {
                centerNode = group.toNode;
                otherNode = group.fromNode;
                isOutflow = false;
            }

            // ç¢ºå®šè³‡é‡‘æµå‹•çš„å¯¦éš›ä¾†æºå’Œç›®æ¨™
            const sourceNode = isOutflow ? centerNode : otherNode;
            const targetNode = isOutflow ? otherNode : centerNode;

            flows.forEach((tx, i) => {
                const tokenClass = tx.token === 'USDT' ? 'usdt' : 'trx';
                // ä½¿ç”¨é å…ˆè¨ˆç®—å¥½çš„æ¨™ç±¤ Y ä½ç½®ï¼ˆå·²è™•ç†ç¢°æ’ï¼‰
                const labelY = labelYPositions[i] || ((sourceNode.y + targetNode.y) / 2 + NODE_HEIGHT / 2);

                // è¨ˆç®—æ›²ç·šåº§æ¨™ï¼ˆå¾ source åˆ° targetï¼‰
                const goingRight = sourceNode.x < targetNode.x;
                let startX, startY, endX, endY;

                if (goingRight) {
                    startX = sourceNode.x + NODE_WIDTH;
                    startY = sourceNode.y + NODE_HEIGHT / 2;
                    endX = targetNode.x;
                    endY = targetNode.y + NODE_HEIGHT / 2;
                } else {
                    startX = sourceNode.x;
                    startY = sourceNode.y + NODE_HEIGHT / 2;
                    endX = targetNode.x + NODE_WIDTH;
                    endY = targetNode.y + NODE_HEIGHT / 2;
                }

                // æ¨™ç±¤æ–‡å­—
                const timeStr = tx.txList?.[0]?.time || '';
                const labelText = `[${timeStr}] ${tx.amount}`;
                const labelW = labelText.length * 6;
                const labelX = (startX + endX) / 2;
                const labelLeft = labelX - labelW / 2;
                const labelRight = labelX + labelW / 2;

                // è¨ˆç®—è²èŒ²æ›²ç·šæ§åˆ¶é»ï¼ˆåƒè€ƒ MetaSleuthï¼šä½¿ç”¨ 50% è·é›¢ï¼‰
                const seg1EndX = goingRight ? labelLeft : labelRight;
                const seg2StartX = goingRight ? labelRight : labelLeft;
                const ctrlX1 = startX + (seg1EndX - startX) * 0.5;
                const ctrlX2 = seg2StartX + (endX - seg2StartX) * 0.5;

                // ç¹ªè£½æ›²ç·š
                const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                path1.setAttribute('d', `M ${startX} ${startY} C ${ctrlX1} ${startY}, ${ctrlX1} ${labelY}, ${seg1EndX} ${labelY}`);
                path2.setAttribute('d', `M ${seg2StartX} ${labelY} C ${ctrlX2} ${labelY}, ${ctrlX2} ${endY}, ${endX} ${endY}`);
                path1.setAttribute('class', `edge-path ${tokenClass}`);
                path2.setAttribute('class', `edge-path ${tokenClass}`);
                g.appendChild(path1);

                // æ¨™ç±¤æ°´å¹³ç·š
                const labelLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                labelLine.setAttribute('x1', labelLeft);
                labelLine.setAttribute('y1', labelY);
                labelLine.setAttribute('x2', labelRight);
                labelLine.setAttribute('y2', labelY);
                labelLine.setAttribute('class', `edge-path ${tokenClass}`);
                g.appendChild(labelLine);

                // æ¨™ç±¤èƒŒæ™¯ï¼ˆæ–¹ä¾¿é»æ“Šï¼‰
                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                labelBg.setAttribute('x', labelLeft - 2);
                labelBg.setAttribute('y', labelY - 14);
                labelBg.setAttribute('width', labelW + 4);
                labelBg.setAttribute('height', 12);
                labelBg.setAttribute('rx', 2);
                labelBg.setAttribute('class', 'label-bg');
                labelBg.setAttribute('data-tx-index', i);
                labelBg.onclick = () => handleLabelClick(tx);
                g.appendChild(labelBg);

                // æ¨™ç±¤æ–‡å­—
                const labelTextEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelTextEl.setAttribute('x', labelLeft);
                labelTextEl.setAttribute('y', labelY - 5);
                labelTextEl.setAttribute('class', `label-text ${tokenClass}`);
                labelTextEl.textContent = labelText;
                labelTextEl.onclick = () => handleLabelClick(tx);
                g.appendChild(labelTextEl);

                g.appendChild(path2);

                // ç®­é ­åœ¨ç›®æ¨™ç¯€é»ï¼ŒæŒ‡å‘è³‡é‡‘æµå…¥æ–¹å‘
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const arrowDir = goingRight ? -1 : 1;  // ç®­é ­æ–¹å‘
                arrow.setAttribute('points', `${endX},${endY} ${endX+arrowDir*8},${endY-4} ${endX+arrowDir*8},${endY+4}`);
                arrow.setAttribute('class', `edge-arrow ${tokenClass}`);
                g.appendChild(arrow);
            });

            svg.appendChild(g);
        }

        // ================= äº‹ä»¶è™•ç† =================
        function handleLabelClick(tx) {
            const panel = document.getElementById('detailPanel');
            const content = document.getElementById('panelContent');
            const linkBtn = document.getElementById('panelLink');
            const typeLabel = document.getElementById('panelType');

            typeLabel.textContent = 'ğŸ’¸ äº¤æ˜“è©³æƒ…';

            // å»ºç«‹äº¤æ˜“æ˜ç´°åˆ—è¡¨
            let txListHtml = '';
            if (tx.txList && tx.txList.length > 0) {
                tx.txList.forEach((t, i) => {
                    const hashLink = t.hash
                        ? `<a href="https://tronscan.org/#/transaction/${t.hash}" target="_blank" style="color:#4fa28a;text-decoration:none;font-size:10px;">æŸ¥çœ‹</a>`
                        : '';
                    txListHtml += `<div style="padding:6px 0;border-bottom:1px solid #2a2a2a;">
                        <div style="display:flex;justify-content:space-between;">
                            <span style="color:${tx.token === 'USDT' ? '#4fa28a' : '#ba3029'}">${t.amountStr || tx.amount}</span>
                            ${hashLink}
                        </div>
                        <div style="font-size:10px;color:#666;margin-top:2px;">${t.time || ''}</div>
                    </div>`;
                });
            }

            const fromAddr = tx.from ? tx.from.replace(/_center|_in|_out$/g, '') : '';
            const toAddr = tx.to ? tx.to.replace(/_center|_in|_out$/g, '') : '';

            content.innerHTML = `
                <div class="data-row"><div class="data-label">é‡‘é¡</div><div class="data-value" style="color: ${tx.token === 'USDT' ? '#4fa28a' : '#ba3029'}">${tx.amount}</div></div>
                <div class="data-row"><div class="data-label">æ–¹å‘</div><div class="data-value">${tx.direction === 'in' ? 'ğŸ“¥ è½‰å…¥' : 'ğŸ“¤ è½‰å‡º'}</div></div>
                <div class="data-row"><div class="data-label">ä¾†æº</div><div class="data-value" style="font-size:10px;">${fromAddr}</div></div>
                <div class="data-row"><div class="data-label">ç›®æ¨™</div><div class="data-value" style="font-size:10px;">${toAddr}</div></div>
                <div class="data-row"><div class="data-label">æ˜ç´°</div><div style="max-height:150px;overflow-y:auto;">${txListHtml || '<span style="color:#666">ç„¡</span>'}</div></div>
            `;
            linkBtn.style.display = 'none';
            panel.classList.add('active');
        }

        function handleNodeClick(node) {
            const panel = document.getElementById('detailPanel');
            const content = document.getElementById('panelContent');
            const linkBtn = document.getElementById('panelLink');
            const typeLabel = document.getElementById('panelType');

            if (node.isTarget) {
                typeLabel.textContent = 'ğŸ¯ ç›®æ¨™åœ°å€';
                content.innerHTML = `<div class="data-row"><div class="data-label">åœ°å€</div><div class="data-value" style="color: #f0b90b">${CONFIG.ROOT_ADDRESS}</div></div>`;
                linkBtn.href = 'https://tronscan.org/#/address/' + CONFIG.ROOT_ADDRESS;
            } else {
                typeLabel.textContent = 'ğŸ“ åœ°å€è©³æƒ…';
                const role = node.isSource ? 'ğŸ“¥ è³‡é‡‘ä¾†æº' : 'ğŸ“¤ è³‡é‡‘å»å‘';
                content.innerHTML = `
                    <div class="data-row"><div class="data-label">åœ°å€</div><div class="data-value" style="color: #4fa28a">${node.address}</div></div>
                    <div class="data-row"><div class="data-label">è§’è‰²</div><div class="data-value">${role}</div></div>
                `;
                linkBtn.href = 'https://tronscan.org/#/address/' + node.address;
            }
            linkBtn.style.display = 'block';
            panel.classList.add('active');
        }

        async function handleNodeDblClick(node) {
            // å·²å±•é–‹çš„ç¯€é»ä¸å†å±•é–‹
            if (expandedCenters.has(node.address)) {
                showToast('â„¹ï¸ æ­¤ç¯€é»å·²å±•é–‹');
                return;
            }

            showToast('â³ è¼‰å…¥ ' + node.address.slice(0, 8) + '...');
            const success = await loadData(node.address, true);
            if (success) {
                showToast('âœ… å·²å±•é–‹');
            }
        }

        function closePanel() {
            document.getElementById('detailPanel').classList.remove('active');
        }

        // ================= è¼”åŠ©å‡½æ•¸ =================
        function updateStats(filteredTx) {
            let usdtTotal = 0, trxTotal = 0;
            filteredTx.forEach(tx => {
                if (tx.token === 'USDT') usdtTotal += tx.rawAmount;
                else if (tx.token === 'TRX') trxTotal += tx.rawAmount;
            });
            const addrs = new Set(filteredTx.map(t => t.direction === 'in' ? t.from : t.to));

            document.getElementById('statNodes').textContent = 'äº¤æ˜“æ•¸ï¼š' + filteredTx.length;
            document.getElementById('statEdges').textContent = 'åœ°å€æ•¸ï¼š' + addrs.size;
            document.getElementById('statUsdt').textContent = 'USDT ç¸½é¡ï¼š' + formatNumber(usdtTotal);
            document.getElementById('statTrx').textContent = 'TRX ç¸½é¡ï¼š' + formatNumber(trxTotal);
        }

        function formatNumber(num) {
            if (num === 0) return '0';
            const fixed = num % 1 === 0 ? num.toString() : num.toFixed(2);
            return fixed.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateTopInfo() {
            const shortAddr = CONFIG.ROOT_ADDRESS.slice(0, 8) + '...' + CONFIG.ROOT_ADDRESS.slice(-6);
            document.getElementById('topInfo').textContent = shortAddr;
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerHTML = msg;
            toast.className = 'toast show';
            setTimeout(() => { toast.className = 'toast'; }, 3000);
        }

        init();
    </script>
</body>
</html>
